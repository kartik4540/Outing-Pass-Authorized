{"ast":null,"code":"import { supabase } from '../supabaseClient';\n\n// No longer need API_BASE_URL as we're using Supabase directly\n\n/**\r\n * Helper function to handle errors\r\n * @param {Error} error - The error object\r\n * @returns {Error} - Formatted error\r\n */\nconst handleError = error => {\n  console.error('API error:', error);\n  return new Error(error.message || 'An error occurred with the Supabase request');\n};\n\n/**\r\n * Fetch available seats for a given date and lab\r\n * @param {string} date - The date to fetch available seats for\r\n * @param {string} lab - The lab to fetch available seats for\r\n * @param {string} dayOrder - The manually selected day order\r\n * @returns {Promise<Object>} - Available seats data\r\n */\nexport const fetchAvailableSeats = async (date, lab, dayOrder) => {\n  try {\n    // Query available_seats view or function in Supabase\n    const {\n      data,\n      error\n    } = await supabase.from('lab_bookings').select('*').eq('date', date).eq('lab', lab).in('status', ['confirmed', 'waiting']); // Check both confirmed and waiting bookings\n\n    if (error) throw error;\n\n    // Transform data to match the expected format\n    const bookedSlots = data.map(booking => booking.time_slot);\n\n    // Get all time slots\n    const allTimeSlots = [\"08:00-08:50\", \"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\", \"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"];\n\n    // Define regular class slots for each lab and day order combination\n    const regularClassSlots = {\n      'LAB A': {\n        '1': [],\n        // No regular classes\n        '2': [],\n        // No regular classes\n        '3': [\"10:40-11:30\", \"03:10-04:00\"],\n        // 10:40 AM to 11:30 AM and 3:10 PM to 4:00 PM\n        '4': [\"08:00-08:50\", \"08:50-09:40\", \"12:30-01:20\", \"01:25-02:15\"],\n        // 8:00 AM to 9:40 AM and 12:30 PM to 2:15 PM\n        '5': [\"09:45-10:35\", \"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\", \"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"] // 9:45 AM to 4:50 PM\n      },\n      'LAB B': {\n        '1': [],\n        // No regular classes\n        '2': [],\n        // No regular classes\n        '3': [],\n        // No regular classes\n        '4': [],\n        // No regular classes\n        '5': [] // No regular classes\n      },\n      'LAB C': {\n        '1': [],\n        // No regular classes\n        '2': [],\n        // No regular classes\n        '3': [],\n        // No regular classes\n        '4': [],\n        // No regular classes\n        '5': [] // No regular classes\n      },\n      'LAB D': {\n        '1': [\"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"],\n        // 2:10 PM to 4:30 PM\n        '2': [\"01:25-02:15\", \"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"],\n        // 1:25 PM to 4:55 PM\n        '3': [\"09:45-10:35\", \"10:40-11:30\"],\n        // 9:45 AM to 11:30 AM\n        '4': [],\n        // NIL - no slots to freeze\n        '5': [\"08:00-08:50\", \"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\"] // 8:00 AM to 11:30 AM\n      }\n    };\n\n    // Calculate available slots\n    const availableSlots = allTimeSlots.map(slot => ({\n      time_slot: slot,\n      available: !bookedSlots.includes(slot) && (!regularClassSlots[lab] || !regularClassSlots[lab][dayOrder] || !regularClassSlots[lab][dayOrder].includes(slot))\n    }));\n    return {\n      availableSlots,\n      dayOrder\n    };\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Book a lab slot\r\n * @param {Object} bookingData - The booking data\r\n * @returns {Promise<Object>} - Booking confirmation\r\n */\nexport const bookSlot = async bookingData => {\n  try {\n    // Ensure timeSlots is an array\n    if (bookingData.timeSlot) {\n      bookingData.timeSlots = [bookingData.timeSlot];\n      delete bookingData.timeSlot;\n    } else if (!bookingData.timeSlots) {\n      bookingData.timeSlots = [];\n    }\n\n    // Validate required fields\n    if (!bookingData.date || !bookingData.lab || !bookingData.timeSlots || bookingData.timeSlots.length === 0) {\n      throw new Error('Missing required fields: date, lab, and at least one time slot are required.');\n    }\n\n    // Create a booking for each time slot\n    const bookingPromises = bookingData.timeSlots.map(async timeSlot => {\n      // First check if there's any existing active booking for this slot\n      const {\n        data: existingBookings,\n        error: checkError\n      } = await supabase.from('lab_bookings').select('*').eq('date', bookingData.date).eq('lab', bookingData.lab).eq('time_slot', timeSlot).in('status', ['waiting', 'confirmed']); // Only check waiting and confirmed bookings\n\n      if (checkError) throw checkError;\n\n      // If there's an existing active booking, throw an error\n      if (existingBookings && existingBookings.length > 0) {\n        throw new Error(`The slot ${timeSlot} is already booked or pending approval.`);\n      }\n\n      // If no existing active booking, proceed with insertion\n      const {\n        data,\n        error\n      } = await supabase.from('lab_bookings').insert([{\n        date: bookingData.date,\n        lab: bookingData.lab,\n        time_slot: timeSlot,\n        email: bookingData.email,\n        name: bookingData.name,\n        faculty_id: bookingData.facultyId,\n        department: bookingData.department,\n        day_order: bookingData.dayOrder,\n        status: 'waiting' // Initial status is waiting for admin approval\n      }]).select();\n      if (error) {\n        // If there's a unique constraint violation, delete any rejected booking and try again\n        if (error.code === '23505') {\n          // Postgres unique constraint violation code\n          // Delete the rejected booking\n          await supabase.from('lab_bookings').delete().match({\n            date: bookingData.date,\n            lab: bookingData.lab,\n            time_slot: timeSlot,\n            status: 'rejected'\n          });\n\n          // Try inserting again\n          const {\n            data: retryData,\n            error: retryError\n          } = await supabase.from('lab_bookings').insert([{\n            date: bookingData.date,\n            lab: bookingData.lab,\n            time_slot: timeSlot,\n            email: bookingData.email,\n            name: bookingData.name,\n            faculty_id: bookingData.facultyId,\n            department: bookingData.department,\n            day_order: bookingData.dayOrder,\n            status: 'waiting' // Initial status is waiting for admin approval\n          }]).select();\n          if (retryError) throw retryError;\n          return retryData[0];\n        }\n        throw error;\n      }\n      return data[0];\n    });\n    const results = await Promise.all(bookingPromises.map(p => p.catch(e => e)));\n\n    // Check if any of the results are errors\n    const errors = results.filter(r => r instanceof Error);\n    if (errors.length > 0) {\n      throw new Error(errors.map(e => e.message).join('\\n'));\n    }\n    return {\n      success: true,\n      message: 'Booking requests submitted successfully',\n      bookings: results\n    };\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Fetch booked slots for a user\r\n * @param {string} email - The user's email\r\n * @returns {Promise<Array>} - Array of booked slots with counts\r\n */\nexport const fetchBookedSlots = async email => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('lab_bookings').select('*').eq('email', email);\n    if (error) throw error;\n\n    // Calculate counts for each status\n    const waiting = data.filter(booking => booking.status === 'waiting').length;\n    const confirmed = data.filter(booking => booking.status === 'confirmed').length;\n    const rejected = data.filter(booking => booking.status === 'rejected').length;\n\n    // Add counts to the response\n    data.counts = {\n      waiting,\n      confirmed,\n      rejected\n    };\n\n    // Format dates for display\n    data.forEach(booking => {\n      if (booking.date) {\n        const date = new Date(booking.date);\n        booking.formatted_date = date.toLocaleDateString('en-US', {\n          weekday: 'long',\n          year: 'numeric',\n          month: 'long',\n          day: 'numeric'\n        });\n      }\n    });\n    return data;\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Delete a booked slot\r\n * @param {number} slotId - The slot ID to delete\r\n * @returns {Promise<Object>} - Deletion confirmation\r\n */\nexport const deleteBookedSlot = async slotId => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('lab_bookings').delete().eq('id', slotId).select();\n    if (error) throw error;\n    return {\n      success: true,\n      message: 'Booking deleted successfully'\n    };\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Fetch all bookings (admin only)\r\n * @param {string} adminEmail - The admin's email\r\n * @returns {Promise<Array>} - Array of all bookings\r\n */\nexport const fetchPendingBookings = async adminEmail => {\n  try {\n    // Fetch all bookings with better error handling\n    const {\n      data,\n      error\n    } = await supabase.from('lab_bookings').select('*').eq('status', 'waiting') // Only fetch pending (waiting) bookings\n    .order('date', {\n      ascending: false\n    });\n    if (error) {\n      console.error('Supabase error fetching pending bookings:', error);\n      throw new Error(`Failed to fetch pending bookings: ${error.message}`);\n    }\n    if (!data) {\n      console.error('No data returned from pending bookings query');\n      throw new Error('No booking data available');\n    }\n\n    // Format dates for display\n    const formattedData = data.map(booking => {\n      if (booking.date) {\n        const date = new Date(booking.date);\n        return {\n          ...booking,\n          formatted_date: date.toLocaleDateString('en-US', {\n            weekday: 'long',\n            year: 'numeric',\n            month: 'long',\n            day: 'numeric'\n          })\n        };\n      }\n      return booking;\n    });\n    return formattedData;\n  } catch (error) {\n    console.error('Error in fetchPendingBookings:', error);\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Handle booking action (confirm/reject)\r\n * @param {number} bookingId - The booking ID to update\r\n * @param {string} action - The action to perform ('confirm' or 'reject')\r\n * @param {string} adminEmail - The admin's email\r\n * @returns {Promise<Object>} - Action confirmation\r\n */\nexport const handleBookingAction = async (bookingId, action, adminEmail) => {\n  try {\n    // For now, we'll bypass the admin check to make the function work\n    // We'll assume the frontend UI will only show this option to admin users\n\n    // Update the booking status\n    const newStatus = action === 'confirm' ? 'confirmed' : 'rejected';\n    const {\n      data,\n      error\n    } = await supabase.from('lab_bookings').update({\n      status: newStatus\n    }).eq('id', bookingId).select();\n    if (error) throw error;\n    return {\n      success: true,\n      message: `Booking ${newStatus} successfully`,\n      booking: data[0]\n    };\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Fetch day order for a date\r\n * @param {string} date - The date to fetch day order for\r\n * @returns {Promise<Object>} - Day order data\r\n */\nexport const fetchDayOrder = async date => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('day_orders').select('*').eq('date', date);\n    if (error) throw error;\n    return data.length > 0 ? data[0] : {\n      date,\n      day_order: null\n    };\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Set day order reference (admin only)\r\n * @param {string} adminEmail - The admin's email\r\n * @param {string} referenceDate - The reference date\r\n * @param {string} dayOrder - The day order\r\n * @returns {Promise<Object>} - Confirmation\r\n */\nexport const setDayOrderReference = async (adminEmail, referenceDate, dayOrder) => {\n  try {\n    // For now, we'll bypass the admin check to make the function work\n    // We'll assume the frontend UI will only show this option to admin users\n\n    // Upsert the day order\n    const {\n      data,\n      error\n    } = await supabase.from('day_orders').upsert([{\n      date: referenceDate,\n      day_order: dayOrder\n    }]).select();\n    if (error) throw error;\n    return {\n      success: true,\n      message: 'Day order set successfully',\n      day_order: data[0]\n    };\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Get day order references (admin only)\r\n * @param {string} adminEmail - The admin's email\r\n * @returns {Promise<Array>} - Array of day order references\r\n */\nexport const getDayOrderReferences = async adminEmail => {\n  try {\n    // For now, we'll bypass the admin check to make the function work\n    // We'll assume the frontend UI will only show this option to admin users\n\n    // Fetch all day orders\n    const {\n      data,\n      error\n    } = await supabase.from('day_orders').select('*').order('date', {\n      ascending: false\n    });\n    if (error) throw error;\n    return data;\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n// Health check function checks if we can connect to Supabase\nexport const checkApiHealth = async () => {\n  try {\n    // First try to fetch a public table that should exist\n    try {\n      const {\n        error\n      } = await supabase.from('health_check').select('count').limit(1);\n      if (!error) return true;\n    } catch (e) {\n      console.log('Health check table not found, trying alternate method');\n    }\n\n    // If that fails, try a simple auth ping which should always work\n    const {\n      error\n    } = await supabase.auth.getSession();\n    return !error;\n  } catch (error) {\n    console.error('Supabase connection error:', error);\n    return false;\n  }\n};","map":{"version":3,"names":["supabase","handleError","error","console","Error","message","fetchAvailableSeats","date","lab","dayOrder","data","from","select","eq","in","bookedSlots","map","booking","time_slot","allTimeSlots","regularClassSlots","availableSlots","slot","available","includes","bookSlot","bookingData","timeSlot","timeSlots","length","bookingPromises","existingBookings","checkError","insert","email","name","faculty_id","facultyId","department","day_order","status","code","delete","match","retryData","retryError","results","Promise","all","p","catch","e","errors","filter","r","join","success","bookings","fetchBookedSlots","waiting","confirmed","rejected","counts","forEach","Date","formatted_date","toLocaleDateString","weekday","year","month","day","deleteBookedSlot","slotId","fetchPendingBookings","adminEmail","order","ascending","formattedData","handleBookingAction","bookingId","action","newStatus","update","fetchDayOrder","setDayOrderReference","referenceDate","upsert","getDayOrderReferences","checkApiHealth","limit","log","auth","getSession"],"sources":["C:/Users/91989/Downloads/Slot-Booking/frontend-supabase/src/services/api.js"],"sourcesContent":["import { supabase } from '../supabaseClient';\r\n\r\n// No longer need API_BASE_URL as we're using Supabase directly\r\n\r\n/**\r\n * Helper function to handle errors\r\n * @param {Error} error - The error object\r\n * @returns {Error} - Formatted error\r\n */\r\nconst handleError = (error) => {\r\n  console.error('API error:', error);\r\n  return new Error(error.message || 'An error occurred with the Supabase request');\r\n};\r\n\r\n/**\r\n * Fetch available seats for a given date and lab\r\n * @param {string} date - The date to fetch available seats for\r\n * @param {string} lab - The lab to fetch available seats for\r\n * @param {string} dayOrder - The manually selected day order\r\n * @returns {Promise<Object>} - Available seats data\r\n */\r\nexport const fetchAvailableSeats = async (date, lab, dayOrder) => {\r\n  try {\r\n    // Query available_seats view or function in Supabase\r\n    const { data, error } = await supabase\r\n      .from('lab_bookings')\r\n      .select('*')\r\n      .eq('date', date)\r\n      .eq('lab', lab)\r\n      .in('status', ['confirmed', 'waiting']); // Check both confirmed and waiting bookings\r\n    \r\n    if (error) throw error;\r\n    \r\n    // Transform data to match the expected format\r\n    const bookedSlots = data.map(booking => booking.time_slot);\r\n    \r\n    // Get all time slots\r\n    const allTimeSlots = [\r\n      \"08:00-08:50\", \"08:50-09:40\", \"09:45-10:35\", \r\n      \"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\", \r\n      \"01:25-02:15\", \"02:20-03:10\", \"03:10-04:00\", \r\n      \"04:00-04:50\"\r\n    ];\r\n\r\n    // Define regular class slots for each lab and day order combination\r\n    const regularClassSlots = {\r\n      'LAB A': {\r\n        '1': [],  // No regular classes\r\n        '2': [],  // No regular classes\r\n        '3': [\"10:40-11:30\", \"03:10-04:00\"],  // 10:40 AM to 11:30 AM and 3:10 PM to 4:00 PM\r\n        '4': [\"08:00-08:50\", \"08:50-09:40\", \"12:30-01:20\", \"01:25-02:15\"],  // 8:00 AM to 9:40 AM and 12:30 PM to 2:15 PM\r\n        '5': [\"09:45-10:35\", \"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\", \"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"]  // 9:45 AM to 4:50 PM\r\n      },\r\n      'LAB B': {\r\n        '1': [],  // No regular classes\r\n        '2': [],  // No regular classes\r\n        '3': [],  // No regular classes\r\n        '4': [],  // No regular classes\r\n        '5': []   // No regular classes\r\n      },\r\n      'LAB C': {\r\n        '1': [],  // No regular classes\r\n        '2': [],  // No regular classes\r\n        '3': [],  // No regular classes\r\n        '4': [],  // No regular classes\r\n        '5': []   // No regular classes\r\n      },\r\n      'LAB D': {\r\n        '1': [\"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"],  // 2:10 PM to 4:30 PM\r\n        '2': [\"01:25-02:15\", \"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"],  // 1:25 PM to 4:55 PM\r\n        '3': [\"09:45-10:35\", \"10:40-11:30\"],  // 9:45 AM to 11:30 AM\r\n        '4': [],  // NIL - no slots to freeze\r\n        '5': [\"08:00-08:50\", \"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\"]  // 8:00 AM to 11:30 AM\r\n      }\r\n    };\r\n    \r\n    // Calculate available slots\r\n    const availableSlots = allTimeSlots.map(slot => ({\r\n      time_slot: slot,\r\n      available: !bookedSlots.includes(slot) && \r\n                (!regularClassSlots[lab] || !regularClassSlots[lab][dayOrder] || !regularClassSlots[lab][dayOrder].includes(slot))\r\n    }));\r\n    \r\n    return { \r\n      availableSlots,\r\n      dayOrder\r\n    };\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Book a lab slot\r\n * @param {Object} bookingData - The booking data\r\n * @returns {Promise<Object>} - Booking confirmation\r\n */\r\nexport const bookSlot = async (bookingData) => {\r\n  try {\r\n    // Ensure timeSlots is an array\r\n    if (bookingData.timeSlot) {\r\n      bookingData.timeSlots = [bookingData.timeSlot];\r\n      delete bookingData.timeSlot;\r\n    } else if (!bookingData.timeSlots) {\r\n      bookingData.timeSlots = [];\r\n    }\r\n\r\n    // Validate required fields\r\n    if (!bookingData.date || !bookingData.lab || !bookingData.timeSlots || bookingData.timeSlots.length === 0) {\r\n      throw new Error('Missing required fields: date, lab, and at least one time slot are required.');\r\n    }\r\n\r\n    // Create a booking for each time slot\r\n    const bookingPromises = bookingData.timeSlots.map(async (timeSlot) => {\r\n      // First check if there's any existing active booking for this slot\r\n      const { data: existingBookings, error: checkError } = await supabase\r\n        .from('lab_bookings')\r\n        .select('*')\r\n        .eq('date', bookingData.date)\r\n        .eq('lab', bookingData.lab)\r\n        .eq('time_slot', timeSlot)\r\n        .in('status', ['waiting', 'confirmed']); // Only check waiting and confirmed bookings\r\n\r\n      if (checkError) throw checkError;\r\n\r\n      // If there's an existing active booking, throw an error\r\n      if (existingBookings && existingBookings.length > 0) {\r\n        throw new Error(`The slot ${timeSlot} is already booked or pending approval.`);\r\n      }\r\n\r\n      // If no existing active booking, proceed with insertion\r\n      const { data, error } = await supabase\r\n        .from('lab_bookings')\r\n        .insert([\r\n          { \r\n            date: bookingData.date,\r\n            lab: bookingData.lab,\r\n            time_slot: timeSlot,\r\n            email: bookingData.email,\r\n            name: bookingData.name,\r\n            faculty_id: bookingData.facultyId,\r\n            department: bookingData.department,\r\n            day_order: bookingData.dayOrder,\r\n            status: 'waiting' // Initial status is waiting for admin approval\r\n          }\r\n        ])\r\n        .select();\r\n\r\n      if (error) {\r\n        // If there's a unique constraint violation, delete any rejected booking and try again\r\n        if (error.code === '23505') { // Postgres unique constraint violation code\r\n          // Delete the rejected booking\r\n          await supabase\r\n            .from('lab_bookings')\r\n            .delete()\r\n            .match({\r\n              date: bookingData.date,\r\n              lab: bookingData.lab,\r\n              time_slot: timeSlot,\r\n              status: 'rejected'\r\n            });\r\n\r\n          // Try inserting again\r\n          const { data: retryData, error: retryError } = await supabase\r\n            .from('lab_bookings')\r\n            .insert([\r\n              { \r\n                date: bookingData.date,\r\n                lab: bookingData.lab,\r\n                time_slot: timeSlot,\r\n                email: bookingData.email,\r\n                name: bookingData.name,\r\n                faculty_id: bookingData.facultyId,\r\n                department: bookingData.department,\r\n                day_order: bookingData.dayOrder,\r\n                status: 'waiting' // Initial status is waiting for admin approval\r\n              }\r\n            ])\r\n            .select();\r\n\r\n          if (retryError) throw retryError;\r\n          return retryData[0];\r\n        }\r\n        throw error;\r\n      }\r\n      return data[0];\r\n    });\r\n\r\n    const results = await Promise.all(bookingPromises.map(p => p.catch(e => e)));\r\n    \r\n    // Check if any of the results are errors\r\n    const errors = results.filter(r => r instanceof Error);\r\n    if (errors.length > 0) {\r\n      throw new Error(errors.map(e => e.message).join('\\n'));\r\n    }\r\n    \r\n    return { \r\n      success: true, \r\n      message: 'Booking requests submitted successfully', \r\n      bookings: results \r\n    };\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Fetch booked slots for a user\r\n * @param {string} email - The user's email\r\n * @returns {Promise<Array>} - Array of booked slots with counts\r\n */\r\nexport const fetchBookedSlots = async (email) => {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('lab_bookings')\r\n      .select('*')\r\n      .eq('email', email);\r\n    \r\n    if (error) throw error;\r\n    \r\n    // Calculate counts for each status\r\n    const waiting = data.filter(booking => booking.status === 'waiting').length;\r\n    const confirmed = data.filter(booking => booking.status === 'confirmed').length;\r\n    const rejected = data.filter(booking => booking.status === 'rejected').length;\r\n    \r\n    // Add counts to the response\r\n    data.counts = { waiting, confirmed, rejected };\r\n    \r\n    // Format dates for display\r\n    data.forEach(booking => {\r\n      if (booking.date) {\r\n        const date = new Date(booking.date);\r\n        booking.formatted_date = date.toLocaleDateString('en-US', {\r\n          weekday: 'long',\r\n          year: 'numeric',\r\n          month: 'long',\r\n          day: 'numeric'\r\n        });\r\n      }\r\n    });\r\n    \r\n    return data;\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Delete a booked slot\r\n * @param {number} slotId - The slot ID to delete\r\n * @returns {Promise<Object>} - Deletion confirmation\r\n */\r\nexport const deleteBookedSlot = async (slotId) => {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('lab_bookings')\r\n      .delete()\r\n      .eq('id', slotId)\r\n      .select();\r\n    \r\n    if (error) throw error;\r\n    \r\n    return { success: true, message: 'Booking deleted successfully' };\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Fetch all bookings (admin only)\r\n * @param {string} adminEmail - The admin's email\r\n * @returns {Promise<Array>} - Array of all bookings\r\n */\r\nexport const fetchPendingBookings = async (adminEmail) => {\r\n  try {\r\n    // Fetch all bookings with better error handling\r\n    const { data, error } = await supabase\r\n      .from('lab_bookings')\r\n      .select('*')\r\n      .eq('status', 'waiting') // Only fetch pending (waiting) bookings\r\n      .order('date', { ascending: false });\r\n    \r\n    if (error) {\r\n      console.error('Supabase error fetching pending bookings:', error);\r\n      throw new Error(`Failed to fetch pending bookings: ${error.message}`);\r\n    }\r\n    \r\n    if (!data) {\r\n      console.error('No data returned from pending bookings query');\r\n      throw new Error('No booking data available');\r\n    }\r\n    \r\n    // Format dates for display\r\n    const formattedData = data.map(booking => {\r\n      if (booking.date) {\r\n        const date = new Date(booking.date);\r\n        return {\r\n          ...booking,\r\n          formatted_date: date.toLocaleDateString('en-US', {\r\n            weekday: 'long',\r\n            year: 'numeric',\r\n            month: 'long',\r\n            day: 'numeric'\r\n          })\r\n        };\r\n      }\r\n      return booking;\r\n    });\r\n    \r\n    return formattedData;\r\n  } catch (error) {\r\n    console.error('Error in fetchPendingBookings:', error);\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Handle booking action (confirm/reject)\r\n * @param {number} bookingId - The booking ID to update\r\n * @param {string} action - The action to perform ('confirm' or 'reject')\r\n * @param {string} adminEmail - The admin's email\r\n * @returns {Promise<Object>} - Action confirmation\r\n */\r\nexport const handleBookingAction = async (bookingId, action, adminEmail) => {\r\n  try {\r\n    // For now, we'll bypass the admin check to make the function work\r\n    // We'll assume the frontend UI will only show this option to admin users\r\n    \r\n    // Update the booking status\r\n    const newStatus = action === 'confirm' ? 'confirmed' : 'rejected';\r\n    \r\n    const { data, error } = await supabase\r\n      .from('lab_bookings')\r\n      .update({ status: newStatus })\r\n      .eq('id', bookingId)\r\n      .select();\r\n    \r\n    if (error) throw error;\r\n    \r\n    return { \r\n      success: true, \r\n      message: `Booking ${newStatus} successfully`, \r\n      booking: data[0] \r\n    };\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Fetch day order for a date\r\n * @param {string} date - The date to fetch day order for\r\n * @returns {Promise<Object>} - Day order data\r\n */\r\nexport const fetchDayOrder = async (date) => {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('day_orders')\r\n      .select('*')\r\n      .eq('date', date);\r\n    \r\n    if (error) throw error;\r\n    \r\n    return data.length > 0 ? data[0] : { date, day_order: null };\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Set day order reference (admin only)\r\n * @param {string} adminEmail - The admin's email\r\n * @param {string} referenceDate - The reference date\r\n * @param {string} dayOrder - The day order\r\n * @returns {Promise<Object>} - Confirmation\r\n */\r\nexport const setDayOrderReference = async (adminEmail, referenceDate, dayOrder) => {\r\n  try {\r\n    // For now, we'll bypass the admin check to make the function work\r\n    // We'll assume the frontend UI will only show this option to admin users\r\n    \r\n    // Upsert the day order\r\n    const { data, error } = await supabase\r\n      .from('day_orders')\r\n      .upsert([\r\n        { date: referenceDate, day_order: dayOrder }\r\n      ])\r\n      .select();\r\n    \r\n    if (error) throw error;\r\n    \r\n    return { \r\n      success: true, \r\n      message: 'Day order set successfully', \r\n      day_order: data[0] \r\n    };\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Get day order references (admin only)\r\n * @param {string} adminEmail - The admin's email\r\n * @returns {Promise<Array>} - Array of day order references\r\n */\r\nexport const getDayOrderReferences = async (adminEmail) => {\r\n  try {\r\n    // For now, we'll bypass the admin check to make the function work\r\n    // We'll assume the frontend UI will only show this option to admin users\r\n    \r\n    // Fetch all day orders\r\n    const { data, error } = await supabase\r\n      .from('day_orders')\r\n      .select('*')\r\n      .order('date', { ascending: false });\r\n    \r\n    if (error) throw error;\r\n    \r\n    return data;\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n// Health check function checks if we can connect to Supabase\r\nexport const checkApiHealth = async () => {\r\n  try {\r\n    // First try to fetch a public table that should exist\r\n    try {\r\n      const { error } = await supabase.from('health_check').select('count').limit(1);\r\n      if (!error) return true;\r\n    } catch (e) {\r\n      console.log('Health check table not found, trying alternate method');\r\n    }\r\n    \r\n    // If that fails, try a simple auth ping which should always work\r\n    const { error } = await supabase.auth.getSession();\r\n    return !error;\r\n  } catch (error) {\r\n    console.error('Supabase connection error:', error);\r\n    return false;\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}