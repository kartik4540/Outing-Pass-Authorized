{"ast":null,"code":"import { supabase } from '../supabaseClient';\n\n// No longer need API_BASE_URL as we're using Supabase directly\n\n/**\r\n * Helper function to handle errors\r\n * @param {Error} error - The error object\r\n * @returns {Error} - Formatted error\r\n */\nconst handleError = error => {\n  console.error('API error:', error);\n  return new Error(error.message || 'An error occurred with the Supabase request');\n};\n\n/**\r\n * Fetch available seats for a given date and lab\r\n * @param {string} date - The date to fetch available seats for\r\n * @param {string} lab - The lab to fetch available seats for\r\n * @param {string} dayOrder - The manually selected day order\r\n * @returns {Promise<Object>} - Available seats data\r\n */\nexport const fetchAvailableSeats = async (date, lab, dayOrder) => {\n  try {\n    // Query available_seats view or function in Supabase\n    const {\n      data: existingBookings,\n      error\n    } = await supabase.from('lab_bookings').select('*').eq('date', date).eq('lab', lab).in('status', ['confirmed', 'waiting']); // Check both confirmed and waiting bookings\n\n    if (error) throw error;\n\n    // Transform data to match the expected format\n    const bookedSlots = existingBookings ? existingBookings.map(booking => booking.time_slot) : [];\n\n    // Get all time slots\n    const allTimeSlots = [\"08:00-08:50\", \"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\", \"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"];\n\n    // Define regular class slots for each lab and day order combination\n    const regularClassSlots = {\n      'LAB A': {\n        '1': [],\n        // No regular classes\n        '2': [],\n        // No regular classes\n        '3': [\"10:40-11:30\", \"03:10-04:00\"],\n        // 10:40 AM to 11:30 AM and 3:10 PM to 4:00 PM\n        '4': [\"08:00-08:50\", \"08:50-09:40\", \"12:30-01:20\", \"01:25-02:15\"],\n        // 8:00 AM to 9:40 AM and 12:30 PM to 2:15 PM\n        '5': [\"09:45-10:35\", \"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\", \"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"] // 9:45 AM to 4:50 PM\n      },\n      'LAB B': {\n        '1': [],\n        // No regular classes\n        '2': [],\n        // No regular classes\n        '3': [],\n        // No regular classes\n        '4': [],\n        // No regular classes\n        '5': [] // No regular classes\n      },\n      'LAB C': {\n        '1': [],\n        // No regular classes\n        '2': [],\n        // No regular classes\n        '3': [],\n        // No regular classes\n        '4': [],\n        // No regular classes\n        '5': [] // No regular classes\n      },\n      'LAB D': {\n        '1': [\"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"],\n        // 2:10 PM to 4:30 PM\n        '2': [\"01:25-02:15\", \"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"],\n        // 1:25 PM to 4:55 PM\n        '3': [\"09:45-10:35\", \"10:40-11:30\"],\n        // 9:45 AM to 11:30 AM\n        '4': [],\n        // NIL - no slots to freeze\n        '5': [\"08:00-08:50\", \"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\"] // 8:00 AM to 11:30 AM\n      }\n    };\n\n    // Calculate available slots\n    const availableSlots = allTimeSlots.map(slot => {\n      var _regularClassSlots$la, _regularClassSlots$la2;\n      const isBooked = bookedSlots.includes(slot);\n      const isRegularClass = ((_regularClassSlots$la = regularClassSlots[lab]) === null || _regularClassSlots$la === void 0 ? void 0 : (_regularClassSlots$la2 = _regularClassSlots$la[dayOrder]) === null || _regularClassSlots$la2 === void 0 ? void 0 : _regularClassSlots$la2.includes(slot)) || false;\n      return {\n        time_slot: slot,\n        available: !isBooked && !isRegularClass,\n        status: isBooked ? 'booked' : isRegularClass ? 'regular_class' : 'available'\n      };\n    });\n    return {\n      availableSlots,\n      dayOrder\n    };\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Book a lab slot\r\n * @param {Object} bookingData - The booking data\r\n * @returns {Promise<Object>} - Booking confirmation\r\n */\nexport const bookSlot = async bookingData => {\n  try {\n    // Ensure timeSlots is an array\n    if (bookingData.timeSlot) {\n      bookingData.timeSlots = [bookingData.timeSlot];\n      delete bookingData.timeSlot;\n    } else if (!bookingData.timeSlots) {\n      bookingData.timeSlots = [];\n    }\n\n    // Validate required fields\n    if (!bookingData.date || !bookingData.lab || !bookingData.timeSlots || bookingData.timeSlots.length === 0) {\n      throw new Error('Missing required fields: date, lab, and at least one time slot are required.');\n    }\n\n    // Create a booking for each time slot\n    const bookingPromises = bookingData.timeSlots.map(async timeSlot => {\n      // First check if there's any existing active booking for this slot\n      const {\n        data: existingBookings,\n        error: checkError\n      } = await supabase.from('lab_bookings').select('*').eq('date', bookingData.date).eq('lab', bookingData.lab).eq('time_slot', timeSlot).in('status', ['waiting', 'confirmed']); // Only check waiting and confirmed bookings\n\n      if (checkError) throw checkError;\n\n      // If there's an existing active booking, throw an error\n      if (existingBookings && existingBookings.length > 0) {\n        throw new Error(`The slot ${timeSlot} is already booked or pending approval.`);\n      }\n\n      // If no existing active booking, proceed with insertion\n      const {\n        data,\n        error\n      } = await supabase.from('lab_bookings').insert([{\n        date: bookingData.date,\n        lab: bookingData.lab,\n        time_slot: timeSlot,\n        email: bookingData.email,\n        name: bookingData.name,\n        faculty_id: bookingData.facultyId,\n        department: bookingData.department,\n        day_order: bookingData.dayOrder,\n        status: 'waiting' // Initial status is waiting for admin approval\n      }]).select();\n      if (error) {\n        // If there's a unique constraint violation, delete any rejected booking and try again\n        if (error.code === '23505') {\n          // Postgres unique constraint violation code\n          // Delete the rejected booking\n          await supabase.from('lab_bookings').delete().match({\n            date: bookingData.date,\n            lab: bookingData.lab,\n            time_slot: timeSlot,\n            status: 'rejected'\n          });\n\n          // Try inserting again\n          const {\n            data: retryData,\n            error: retryError\n          } = await supabase.from('lab_bookings').insert([{\n            date: bookingData.date,\n            lab: bookingData.lab,\n            time_slot: timeSlot,\n            email: bookingData.email,\n            name: bookingData.name,\n            faculty_id: bookingData.facultyId,\n            department: bookingData.department,\n            day_order: bookingData.dayOrder,\n            status: 'waiting' // Initial status is waiting for admin approval\n          }]).select();\n          if (retryError) throw retryError;\n          return retryData[0];\n        }\n        throw error;\n      }\n      return data[0];\n    });\n    const results = await Promise.all(bookingPromises.map(p => p.catch(e => e)));\n\n    // Check if any of the results are errors\n    const errors = results.filter(r => r instanceof Error);\n    if (errors.length > 0) {\n      throw new Error(errors.map(e => e.message).join('\\n'));\n    }\n    return {\n      success: true,\n      message: 'Booking requests submitted successfully',\n      bookings: results\n    };\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Fetch booked slots for a user\r\n * @param {string} email - The user's email\r\n * @returns {Promise<Array>} - Array of booked slots with counts\r\n */\nexport const fetchBookedSlots = async email => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('lab_bookings').select('*').eq('email', email);\n    if (error) throw error;\n\n    // Calculate counts for each status\n    const waiting = data.filter(booking => booking.status === 'waiting').length;\n    const confirmed = data.filter(booking => booking.status === 'confirmed').length;\n    const rejected = data.filter(booking => booking.status === 'rejected').length;\n\n    // Add counts to the response\n    data.counts = {\n      waiting,\n      confirmed,\n      rejected\n    };\n\n    // Format dates for display\n    data.forEach(booking => {\n      if (booking.date) {\n        const date = new Date(booking.date);\n        booking.formatted_date = date.toLocaleDateString('en-US', {\n          weekday: 'long',\n          year: 'numeric',\n          month: 'long',\n          day: 'numeric'\n        });\n      }\n    });\n    return data;\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Delete a booked slot\r\n * @param {number} slotId - The slot ID to delete\r\n * @returns {Promise<Object>} - Deletion confirmation\r\n */\nexport const deleteBookedSlot = async slotId => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('lab_bookings').delete().eq('id', slotId).select();\n    if (error) throw error;\n    return {\n      success: true,\n      message: 'Booking deleted successfully'\n    };\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Fetch all bookings (admin only)\r\n * @param {string} adminEmail - The admin's email\r\n * @returns {Promise<Array>} - Array of all bookings\r\n */\nexport const fetchPendingBookings = async adminEmail => {\n  try {\n    // Fetch all bookings with better error handling\n    const {\n      data,\n      error\n    } = await supabase.from('lab_bookings').select('*')\n    // No status filter - fetch all bookings\n    .order('date', {\n      ascending: false\n    }).order('created_at', {\n      ascending: false\n    });\n    if (error) {\n      console.error('Supabase error fetching bookings:', error);\n      throw new Error(`Failed to fetch bookings: ${error.message}`);\n    }\n    if (!data) {\n      console.error('No data returned from bookings query');\n      throw new Error('No booking data available');\n    }\n\n    // Format dates for display\n    const formattedData = data.map(booking => {\n      if (booking.date) {\n        const date = new Date(booking.date);\n        return {\n          ...booking,\n          formatted_date: date.toLocaleDateString('en-US', {\n            weekday: 'long',\n            year: 'numeric',\n            month: 'long',\n            day: 'numeric'\n          })\n        };\n      }\n      return booking;\n    });\n    return formattedData;\n  } catch (error) {\n    console.error('Error in fetchPendingBookings:', error);\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Handle booking action (confirm/reject)\r\n * @param {number} bookingId - The booking ID to update\r\n * @param {string} action - The action to perform ('confirm' or 'reject')\r\n * @param {string} adminEmail - The admin's email\r\n * @returns {Promise<Object>} - Action confirmation\r\n */\nexport const handleBookingAction = async (bookingId, action, adminEmail) => {\n  try {\n    // For now, we'll bypass the admin check to make the function work\n    // We'll assume the frontend UI will only show this option to admin users\n\n    // Update the booking status\n    const newStatus = action === 'confirm' ? 'confirmed' : 'rejected';\n    const {\n      data,\n      error\n    } = await supabase.from('lab_bookings').update({\n      status: newStatus\n    }).eq('id', bookingId).select();\n    if (error) throw error;\n    return {\n      success: true,\n      message: `Booking ${newStatus} successfully`,\n      booking: data[0]\n    };\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Fetch day order for a date\r\n * @param {string} date - The date to fetch day order for\r\n * @returns {Promise<Object>} - Day order data\r\n */\nexport const fetchDayOrder = async date => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('day_orders').select('*').eq('date', date);\n    if (error) throw error;\n    return data.length > 0 ? data[0] : {\n      date,\n      day_order: null\n    };\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Set day order reference (admin only)\r\n * @param {string} adminEmail - The admin's email\r\n * @param {string} referenceDate - The reference date\r\n * @param {string} dayOrder - The day order\r\n * @returns {Promise<Object>} - Confirmation\r\n */\nexport const setDayOrderReference = async (adminEmail, referenceDate, dayOrder) => {\n  try {\n    // For now, we'll bypass the admin check to make the function work\n    // We'll assume the frontend UI will only show this option to admin users\n\n    // Upsert the day order\n    const {\n      data,\n      error\n    } = await supabase.from('day_orders').upsert([{\n      date: referenceDate,\n      day_order: dayOrder\n    }]).select();\n    if (error) throw error;\n    return {\n      success: true,\n      message: 'Day order set successfully',\n      day_order: data[0]\n    };\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Get day order references (admin only)\r\n * @param {string} adminEmail - The admin's email\r\n * @returns {Promise<Array>} - Array of day order references\r\n */\nexport const getDayOrderReferences = async adminEmail => {\n  try {\n    // For now, we'll bypass the admin check to make the function work\n    // We'll assume the frontend UI will only show this option to admin users\n\n    // Fetch all day orders\n    const {\n      data,\n      error\n    } = await supabase.from('day_orders').select('*').order('date', {\n      ascending: false\n    });\n    if (error) throw error;\n    return data;\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n// Health check function checks if we can connect to Supabase\nexport const checkApiHealth = async () => {\n  try {\n    // First try to fetch a public table that should exist\n    try {\n      const {\n        error\n      } = await supabase.from('health_check').select('count').limit(1);\n      if (!error) return true;\n    } catch (e) {\n      console.log('Health check table not found, trying alternate method');\n    }\n\n    // If that fails, try a simple auth ping which should always work\n    const {\n      error\n    } = await supabase.auth.getSession();\n    return !error;\n  } catch (error) {\n    console.error('Supabase connection error:', error);\n    return false;\n  }\n};","map":{"version":3,"names":["supabase","handleError","error","console","Error","message","fetchAvailableSeats","date","lab","dayOrder","data","existingBookings","from","select","eq","in","bookedSlots","map","booking","time_slot","allTimeSlots","regularClassSlots","availableSlots","slot","_regularClassSlots$la","_regularClassSlots$la2","isBooked","includes","isRegularClass","available","status","bookSlot","bookingData","timeSlot","timeSlots","length","bookingPromises","checkError","insert","email","name","faculty_id","facultyId","department","day_order","code","delete","match","retryData","retryError","results","Promise","all","p","catch","e","errors","filter","r","join","success","bookings","fetchBookedSlots","waiting","confirmed","rejected","counts","forEach","Date","formatted_date","toLocaleDateString","weekday","year","month","day","deleteBookedSlot","slotId","fetchPendingBookings","adminEmail","order","ascending","formattedData","handleBookingAction","bookingId","action","newStatus","update","fetchDayOrder","setDayOrderReference","referenceDate","upsert","getDayOrderReferences","checkApiHealth","limit","log","auth","getSession"],"sources":["C:/Users/91989/Downloads/Slot-Booking/frontend-supabase/src/services/api.js"],"sourcesContent":["import { supabase } from '../supabaseClient';\r\n\r\n// No longer need API_BASE_URL as we're using Supabase directly\r\n\r\n/**\r\n * Helper function to handle errors\r\n * @param {Error} error - The error object\r\n * @returns {Error} - Formatted error\r\n */\r\nconst handleError = (error) => {\r\n  console.error('API error:', error);\r\n  return new Error(error.message || 'An error occurred with the Supabase request');\r\n};\r\n\r\n/**\r\n * Fetch available seats for a given date and lab\r\n * @param {string} date - The date to fetch available seats for\r\n * @param {string} lab - The lab to fetch available seats for\r\n * @param {string} dayOrder - The manually selected day order\r\n * @returns {Promise<Object>} - Available seats data\r\n */\r\nexport const fetchAvailableSeats = async (date, lab, dayOrder) => {\r\n  try {\r\n    // Query available_seats view or function in Supabase\r\n    const { data: existingBookings, error } = await supabase\r\n      .from('lab_bookings')\r\n      .select('*')\r\n      .eq('date', date)\r\n      .eq('lab', lab)\r\n      .in('status', ['confirmed', 'waiting']); // Check both confirmed and waiting bookings\r\n    \r\n    if (error) throw error;\r\n    \r\n    // Transform data to match the expected format\r\n    const bookedSlots = existingBookings ? existingBookings.map(booking => booking.time_slot) : [];\r\n    \r\n    // Get all time slots\r\n    const allTimeSlots = [\r\n      \"08:00-08:50\", \"08:50-09:40\", \"09:45-10:35\", \r\n      \"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\", \r\n      \"01:25-02:15\", \"02:20-03:10\", \"03:10-04:00\", \r\n      \"04:00-04:50\"\r\n    ];\r\n\r\n    // Define regular class slots for each lab and day order combination\r\n    const regularClassSlots = {\r\n      'LAB A': {\r\n        '1': [],  // No regular classes\r\n        '2': [],  // No regular classes\r\n        '3': [\"10:40-11:30\", \"03:10-04:00\"],  // 10:40 AM to 11:30 AM and 3:10 PM to 4:00 PM\r\n        '4': [\"08:00-08:50\", \"08:50-09:40\", \"12:30-01:20\", \"01:25-02:15\"],  // 8:00 AM to 9:40 AM and 12:30 PM to 2:15 PM\r\n        '5': [\"09:45-10:35\", \"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\", \"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"]  // 9:45 AM to 4:50 PM\r\n      },\r\n      'LAB B': {\r\n        '1': [],  // No regular classes\r\n        '2': [],  // No regular classes\r\n        '3': [],  // No regular classes\r\n        '4': [],  // No regular classes\r\n        '5': []   // No regular classes\r\n      },\r\n      'LAB C': {\r\n        '1': [],  // No regular classes\r\n        '2': [],  // No regular classes\r\n        '3': [],  // No regular classes\r\n        '4': [],  // No regular classes\r\n        '5': []   // No regular classes\r\n      },\r\n      'LAB D': {\r\n        '1': [\"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"],  // 2:10 PM to 4:30 PM\r\n        '2': [\"01:25-02:15\", \"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"],  // 1:25 PM to 4:55 PM\r\n        '3': [\"09:45-10:35\", \"10:40-11:30\"],  // 9:45 AM to 11:30 AM\r\n        '4': [],  // NIL - no slots to freeze\r\n        '5': [\"08:00-08:50\", \"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\"]  // 8:00 AM to 11:30 AM\r\n      }\r\n    };\r\n    \r\n    // Calculate available slots\r\n    const availableSlots = allTimeSlots.map(slot => {\r\n      const isBooked = bookedSlots.includes(slot);\r\n      const isRegularClass = regularClassSlots[lab]?.[dayOrder]?.includes(slot) || false;\r\n      \r\n      return {\r\n        time_slot: slot,\r\n        available: !isBooked && !isRegularClass,\r\n        status: isBooked ? 'booked' : isRegularClass ? 'regular_class' : 'available'\r\n      };\r\n    });\r\n    \r\n    return { \r\n      availableSlots,\r\n      dayOrder\r\n    };\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Book a lab slot\r\n * @param {Object} bookingData - The booking data\r\n * @returns {Promise<Object>} - Booking confirmation\r\n */\r\nexport const bookSlot = async (bookingData) => {\r\n  try {\r\n    // Ensure timeSlots is an array\r\n    if (bookingData.timeSlot) {\r\n      bookingData.timeSlots = [bookingData.timeSlot];\r\n      delete bookingData.timeSlot;\r\n    } else if (!bookingData.timeSlots) {\r\n      bookingData.timeSlots = [];\r\n    }\r\n\r\n    // Validate required fields\r\n    if (!bookingData.date || !bookingData.lab || !bookingData.timeSlots || bookingData.timeSlots.length === 0) {\r\n      throw new Error('Missing required fields: date, lab, and at least one time slot are required.');\r\n    }\r\n\r\n    // Create a booking for each time slot\r\n    const bookingPromises = bookingData.timeSlots.map(async (timeSlot) => {\r\n      // First check if there's any existing active booking for this slot\r\n      const { data: existingBookings, error: checkError } = await supabase\r\n        .from('lab_bookings')\r\n        .select('*')\r\n        .eq('date', bookingData.date)\r\n        .eq('lab', bookingData.lab)\r\n        .eq('time_slot', timeSlot)\r\n        .in('status', ['waiting', 'confirmed']); // Only check waiting and confirmed bookings\r\n\r\n      if (checkError) throw checkError;\r\n\r\n      // If there's an existing active booking, throw an error\r\n      if (existingBookings && existingBookings.length > 0) {\r\n        throw new Error(`The slot ${timeSlot} is already booked or pending approval.`);\r\n      }\r\n\r\n      // If no existing active booking, proceed with insertion\r\n      const { data, error } = await supabase\r\n        .from('lab_bookings')\r\n        .insert([\r\n          { \r\n            date: bookingData.date,\r\n            lab: bookingData.lab,\r\n            time_slot: timeSlot,\r\n            email: bookingData.email,\r\n            name: bookingData.name,\r\n            faculty_id: bookingData.facultyId,\r\n            department: bookingData.department,\r\n            day_order: bookingData.dayOrder,\r\n            status: 'waiting' // Initial status is waiting for admin approval\r\n          }\r\n        ])\r\n        .select();\r\n\r\n      if (error) {\r\n        // If there's a unique constraint violation, delete any rejected booking and try again\r\n        if (error.code === '23505') { // Postgres unique constraint violation code\r\n          // Delete the rejected booking\r\n          await supabase\r\n            .from('lab_bookings')\r\n            .delete()\r\n            .match({\r\n              date: bookingData.date,\r\n              lab: bookingData.lab,\r\n              time_slot: timeSlot,\r\n              status: 'rejected'\r\n            });\r\n\r\n          // Try inserting again\r\n          const { data: retryData, error: retryError } = await supabase\r\n            .from('lab_bookings')\r\n            .insert([\r\n              { \r\n                date: bookingData.date,\r\n                lab: bookingData.lab,\r\n                time_slot: timeSlot,\r\n                email: bookingData.email,\r\n                name: bookingData.name,\r\n                faculty_id: bookingData.facultyId,\r\n                department: bookingData.department,\r\n                day_order: bookingData.dayOrder,\r\n                status: 'waiting' // Initial status is waiting for admin approval\r\n              }\r\n            ])\r\n            .select();\r\n\r\n          if (retryError) throw retryError;\r\n          return retryData[0];\r\n        }\r\n        throw error;\r\n      }\r\n      return data[0];\r\n    });\r\n\r\n    const results = await Promise.all(bookingPromises.map(p => p.catch(e => e)));\r\n    \r\n    // Check if any of the results are errors\r\n    const errors = results.filter(r => r instanceof Error);\r\n    if (errors.length > 0) {\r\n      throw new Error(errors.map(e => e.message).join('\\n'));\r\n    }\r\n    \r\n    return { \r\n      success: true, \r\n      message: 'Booking requests submitted successfully', \r\n      bookings: results \r\n    };\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Fetch booked slots for a user\r\n * @param {string} email - The user's email\r\n * @returns {Promise<Array>} - Array of booked slots with counts\r\n */\r\nexport const fetchBookedSlots = async (email) => {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('lab_bookings')\r\n      .select('*')\r\n      .eq('email', email);\r\n    \r\n    if (error) throw error;\r\n    \r\n    // Calculate counts for each status\r\n    const waiting = data.filter(booking => booking.status === 'waiting').length;\r\n    const confirmed = data.filter(booking => booking.status === 'confirmed').length;\r\n    const rejected = data.filter(booking => booking.status === 'rejected').length;\r\n    \r\n    // Add counts to the response\r\n    data.counts = { waiting, confirmed, rejected };\r\n    \r\n    // Format dates for display\r\n    data.forEach(booking => {\r\n      if (booking.date) {\r\n        const date = new Date(booking.date);\r\n        booking.formatted_date = date.toLocaleDateString('en-US', {\r\n          weekday: 'long',\r\n          year: 'numeric',\r\n          month: 'long',\r\n          day: 'numeric'\r\n        });\r\n      }\r\n    });\r\n    \r\n    return data;\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Delete a booked slot\r\n * @param {number} slotId - The slot ID to delete\r\n * @returns {Promise<Object>} - Deletion confirmation\r\n */\r\nexport const deleteBookedSlot = async (slotId) => {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('lab_bookings')\r\n      .delete()\r\n      .eq('id', slotId)\r\n      .select();\r\n    \r\n    if (error) throw error;\r\n    \r\n    return { success: true, message: 'Booking deleted successfully' };\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Fetch all bookings (admin only)\r\n * @param {string} adminEmail - The admin's email\r\n * @returns {Promise<Array>} - Array of all bookings\r\n */\r\nexport const fetchPendingBookings = async (adminEmail) => {\r\n  try {\r\n    // Fetch all bookings with better error handling\r\n    const { data, error } = await supabase\r\n      .from('lab_bookings')\r\n      .select('*')\r\n      // No status filter - fetch all bookings\r\n      .order('date', { ascending: false })\r\n      .order('created_at', { ascending: false });\r\n    \r\n    if (error) {\r\n      console.error('Supabase error fetching bookings:', error);\r\n      throw new Error(`Failed to fetch bookings: ${error.message}`);\r\n    }\r\n    \r\n    if (!data) {\r\n      console.error('No data returned from bookings query');\r\n      throw new Error('No booking data available');\r\n    }\r\n    \r\n    // Format dates for display\r\n    const formattedData = data.map(booking => {\r\n      if (booking.date) {\r\n        const date = new Date(booking.date);\r\n        return {\r\n          ...booking,\r\n          formatted_date: date.toLocaleDateString('en-US', {\r\n            weekday: 'long',\r\n            year: 'numeric',\r\n            month: 'long',\r\n            day: 'numeric'\r\n          })\r\n        };\r\n      }\r\n      return booking;\r\n    });\r\n    \r\n    return formattedData;\r\n  } catch (error) {\r\n    console.error('Error in fetchPendingBookings:', error);\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Handle booking action (confirm/reject)\r\n * @param {number} bookingId - The booking ID to update\r\n * @param {string} action - The action to perform ('confirm' or 'reject')\r\n * @param {string} adminEmail - The admin's email\r\n * @returns {Promise<Object>} - Action confirmation\r\n */\r\nexport const handleBookingAction = async (bookingId, action, adminEmail) => {\r\n  try {\r\n    // For now, we'll bypass the admin check to make the function work\r\n    // We'll assume the frontend UI will only show this option to admin users\r\n    \r\n    // Update the booking status\r\n    const newStatus = action === 'confirm' ? 'confirmed' : 'rejected';\r\n    \r\n    const { data, error } = await supabase\r\n      .from('lab_bookings')\r\n      .update({ status: newStatus })\r\n      .eq('id', bookingId)\r\n      .select();\r\n    \r\n    if (error) throw error;\r\n    \r\n    return { \r\n      success: true, \r\n      message: `Booking ${newStatus} successfully`, \r\n      booking: data[0] \r\n    };\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Fetch day order for a date\r\n * @param {string} date - The date to fetch day order for\r\n * @returns {Promise<Object>} - Day order data\r\n */\r\nexport const fetchDayOrder = async (date) => {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('day_orders')\r\n      .select('*')\r\n      .eq('date', date);\r\n    \r\n    if (error) throw error;\r\n    \r\n    return data.length > 0 ? data[0] : { date, day_order: null };\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Set day order reference (admin only)\r\n * @param {string} adminEmail - The admin's email\r\n * @param {string} referenceDate - The reference date\r\n * @param {string} dayOrder - The day order\r\n * @returns {Promise<Object>} - Confirmation\r\n */\r\nexport const setDayOrderReference = async (adminEmail, referenceDate, dayOrder) => {\r\n  try {\r\n    // For now, we'll bypass the admin check to make the function work\r\n    // We'll assume the frontend UI will only show this option to admin users\r\n    \r\n    // Upsert the day order\r\n    const { data, error } = await supabase\r\n      .from('day_orders')\r\n      .upsert([\r\n        { date: referenceDate, day_order: dayOrder }\r\n      ])\r\n      .select();\r\n    \r\n    if (error) throw error;\r\n    \r\n    return { \r\n      success: true, \r\n      message: 'Day order set successfully', \r\n      day_order: data[0] \r\n    };\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Get day order references (admin only)\r\n * @param {string} adminEmail - The admin's email\r\n * @returns {Promise<Array>} - Array of day order references\r\n */\r\nexport const getDayOrderReferences = async (adminEmail) => {\r\n  try {\r\n    // For now, we'll bypass the admin check to make the function work\r\n    // We'll assume the frontend UI will only show this option to admin users\r\n    \r\n    // Fetch all day orders\r\n    const { data, error } = await supabase\r\n      .from('day_orders')\r\n      .select('*')\r\n      .order('date', { ascending: false });\r\n    \r\n    if (error) throw error;\r\n    \r\n    return data;\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n// Health check function checks if we can connect to Supabase\r\nexport const checkApiHealth = async () => {\r\n  try {\r\n    // First try to fetch a public table that should exist\r\n    try {\r\n      const { error } = await supabase.from('health_check').select('count').limit(1);\r\n      if (!error) return true;\r\n    } catch (e) {\r\n      console.log('Health check table not found, trying alternate method');\r\n    }\r\n    \r\n    // If that fails, try a simple auth ping which should always work\r\n    const { error } = await supabase.auth.getSession();\r\n    return !error;\r\n  } catch (error) {\r\n    console.error('Supabase connection error:', error);\r\n    return false;\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}