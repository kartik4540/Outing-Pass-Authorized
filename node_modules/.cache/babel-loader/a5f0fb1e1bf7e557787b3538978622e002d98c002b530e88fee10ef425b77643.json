{"ast":null,"code":"import { supabase } from '../supabaseClient';\n\n// No longer need API_BASE_URL as we're using Supabase directly\n\n/**\r\n * Helper function to handle errors\r\n * @param {Error} error - The error object\r\n * @returns {Error} - Formatted error\r\n */\nconst handleError = error => {\n  console.error('API error:', error);\n  return new Error(error.message || 'An error occurred with the Supabase request');\n};\n\n/**\r\n * Fetch available seats for a given date and lab\r\n * @param {string} date - The date to fetch available seats for\r\n * @param {string} lab - The lab to fetch available seats for\r\n * @param {string} dayOrder - The manually selected day order\r\n * @returns {Promise<Object>} - Available seats data\r\n */\nexport const fetchAvailableSeats = async (date, lab, dayOrder) => {\n  try {\n    // Query available_seats view or function in Supabase\n    const {\n      data,\n      error\n    } = await supabase.from('lab_bookings').select('*').eq('date', date).eq('lab', lab).eq('status', 'confirmed');\n    if (error) throw error;\n\n    // Transform data to match the expected format\n    const bookedSlots = data.map(booking => booking.time_slot);\n\n    // Get all time slots\n    const allTimeSlots = [\"08:00-08:50\", \"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\", \"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"];\n\n    // Define regular class slots for each lab and day order combination\n    const regularClassSlots = {\n      'Lab A': {\n        '1': [\"08:00-08:50\", \"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\"],\n        '2': [\"09:45-10:35\", \"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\"],\n        '3': [\"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\", \"02:20-03:10\"],\n        '4': [\"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\", \"11:35-12:25\"],\n        '5': [\"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\"]\n      },\n      'Lab B': {\n        '1': [\"09:45-10:35\", \"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\"],\n        '2': [\"08:00-08:50\", \"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\"],\n        '3': [\"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\"],\n        '4': [\"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\", \"02:20-03:10\"],\n        '5': [\"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\", \"11:35-12:25\"]\n      },\n      'Lab C': {\n        '1': [\"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\", \"02:20-03:10\"],\n        '2': [\"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\"],\n        '3': [\"08:00-08:50\", \"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\"],\n        '4': [\"09:45-10:35\", \"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\"],\n        '5': [\"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\", \"02:20-03:10\"]\n      },\n      'Lab D': {\n        '1': [\"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"],\n        // 2:10 PM to 4:30 PM\n        '2': [\"01:25-02:15\", \"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"],\n        // 1:25 PM to 4:55 PM\n        '3': [\"09:45-10:35\", \"10:40-11:30\"],\n        // 9:45 AM to 11:30 AM\n        '4': [],\n        // NIL - no slots to freeze\n        '5': [\"08:00-08:50\", \"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\"] // 8:00 AM to 11:30 AM\n      }\n    };\n\n    // Calculate available slots\n    const availableSlots = allTimeSlots.map(slot => ({\n      time_slot: slot,\n      available: !bookedSlots.includes(slot) && (!regularClassSlots[lab] || !regularClassSlots[lab][dayOrder] || !regularClassSlots[lab][dayOrder].includes(slot))\n    }));\n    return {\n      availableSlots,\n      dayOrder\n    };\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Book a lab slot\r\n * @param {Object} bookingData - The booking data\r\n * @returns {Promise<Object>} - Booking confirmation\r\n */\nexport const bookSlot = async bookingData => {\n  try {\n    // Ensure timeSlots is an array\n    if (bookingData.timeSlot) {\n      bookingData.timeSlots = [bookingData.timeSlot];\n      delete bookingData.timeSlot;\n    } else if (!bookingData.timeSlots) {\n      bookingData.timeSlots = [];\n    }\n\n    // Validate required fields\n    if (!bookingData.date || !bookingData.lab || !bookingData.timeSlots || bookingData.timeSlots.length === 0) {\n      throw new Error('Missing required fields: date, lab, and at least one time slot are required.');\n    }\n\n    // Create a booking for each time slot\n    const bookingPromises = bookingData.timeSlots.map(async timeSlot => {\n      const {\n        data,\n        error\n      } = await supabase.from('lab_bookings').insert([{\n        date: bookingData.date,\n        lab: bookingData.lab,\n        time_slot: timeSlot,\n        email: bookingData.email,\n        name: bookingData.name,\n        faculty_id: bookingData.facultyId,\n        department: bookingData.department,\n        day_order: bookingData.dayOrder,\n        status: 'waiting' // Initial status is waiting for admin approval\n      }]).select();\n      if (error) throw error;\n      return data[0];\n    });\n    const results = await Promise.all(bookingPromises);\n    return {\n      success: true,\n      message: 'Booking requests submitted successfully',\n      bookings: results\n    };\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Fetch booked slots for a user\r\n * @param {string} email - The user's email\r\n * @returns {Promise<Array>} - Array of booked slots with counts\r\n */\nexport const fetchBookedSlots = async email => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('lab_bookings').select('*').eq('email', email);\n    if (error) throw error;\n\n    // Calculate counts for each status\n    const waiting = data.filter(booking => booking.status === 'waiting').length;\n    const confirmed = data.filter(booking => booking.status === 'confirmed').length;\n    const rejected = data.filter(booking => booking.status === 'rejected').length;\n\n    // Add counts to the response\n    data.counts = {\n      waiting,\n      confirmed,\n      rejected\n    };\n\n    // Format dates for display\n    data.forEach(booking => {\n      if (booking.date) {\n        const date = new Date(booking.date);\n        booking.formatted_date = date.toLocaleDateString('en-US', {\n          weekday: 'long',\n          year: 'numeric',\n          month: 'long',\n          day: 'numeric'\n        });\n      }\n    });\n    return data;\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Delete a booked slot\r\n * @param {number} slotId - The slot ID to delete\r\n * @returns {Promise<Object>} - Deletion confirmation\r\n */\nexport const deleteBookedSlot = async slotId => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('lab_bookings').delete().eq('id', slotId).select();\n    if (error) throw error;\n    return {\n      success: true,\n      message: 'Booking deleted successfully'\n    };\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Fetch all bookings (admin only)\r\n * @param {string} adminEmail - The admin's email\r\n * @returns {Promise<Array>} - Array of all bookings\r\n */\nexport const fetchPendingBookings = async adminEmail => {\n  try {\n    // For now, we'll bypass the admin check to make the function work\n    // We'll assume the frontend UI will only show this option to admin users\n\n    // Fetch all bookings\n    const {\n      data,\n      error\n    } = await supabase.from('lab_bookings').select('*').order('date', {\n      ascending: false\n    });\n    if (error) throw error;\n\n    // Format dates for display\n    data.forEach(booking => {\n      if (booking.date) {\n        const date = new Date(booking.date);\n        booking.formatted_date = date.toLocaleDateString('en-US', {\n          weekday: 'long',\n          year: 'numeric',\n          month: 'long',\n          day: 'numeric'\n        });\n      }\n    });\n    return data;\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Handle booking action (confirm/reject)\r\n * @param {number} bookingId - The booking ID to update\r\n * @param {string} action - The action to perform ('confirm' or 'reject')\r\n * @param {string} adminEmail - The admin's email\r\n * @returns {Promise<Object>} - Action confirmation\r\n */\nexport const handleBookingAction = async (bookingId, action, adminEmail) => {\n  try {\n    // For now, we'll bypass the admin check to make the function work\n    // We'll assume the frontend UI will only show this option to admin users\n\n    // Update the booking status\n    const newStatus = action === 'confirm' ? 'confirmed' : 'rejected';\n    const {\n      data,\n      error\n    } = await supabase.from('lab_bookings').update({\n      status: newStatus\n    }).eq('id', bookingId).select();\n    if (error) throw error;\n    return {\n      success: true,\n      message: `Booking ${newStatus} successfully`,\n      booking: data[0]\n    };\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Fetch day order for a date\r\n * @param {string} date - The date to fetch day order for\r\n * @returns {Promise<Object>} - Day order data\r\n */\nexport const fetchDayOrder = async date => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('day_orders').select('*').eq('date', date);\n    if (error) throw error;\n    return data.length > 0 ? data[0] : {\n      date,\n      day_order: null\n    };\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Set day order reference (admin only)\r\n * @param {string} adminEmail - The admin's email\r\n * @param {string} referenceDate - The reference date\r\n * @param {string} dayOrder - The day order\r\n * @returns {Promise<Object>} - Confirmation\r\n */\nexport const setDayOrderReference = async (adminEmail, referenceDate, dayOrder) => {\n  try {\n    // For now, we'll bypass the admin check to make the function work\n    // We'll assume the frontend UI will only show this option to admin users\n\n    // Upsert the day order\n    const {\n      data,\n      error\n    } = await supabase.from('day_orders').upsert([{\n      date: referenceDate,\n      day_order: dayOrder\n    }]).select();\n    if (error) throw error;\n    return {\n      success: true,\n      message: 'Day order set successfully',\n      day_order: data[0]\n    };\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n/**\r\n * Get day order references (admin only)\r\n * @param {string} adminEmail - The admin's email\r\n * @returns {Promise<Array>} - Array of day order references\r\n */\nexport const getDayOrderReferences = async adminEmail => {\n  try {\n    // For now, we'll bypass the admin check to make the function work\n    // We'll assume the frontend UI will only show this option to admin users\n\n    // Fetch all day orders\n    const {\n      data,\n      error\n    } = await supabase.from('day_orders').select('*').order('date', {\n      ascending: false\n    });\n    if (error) throw error;\n    return data;\n  } catch (error) {\n    throw handleError(error);\n  }\n};\n\n// Health check function checks if we can connect to Supabase\nexport const checkApiHealth = async () => {\n  try {\n    // First try to fetch a public table that should exist\n    try {\n      const {\n        error\n      } = await supabase.from('health_check').select('count').limit(1);\n      if (!error) return true;\n    } catch (e) {\n      console.log('Health check table not found, trying alternate method');\n    }\n\n    // If that fails, try a simple auth ping which should always work\n    const {\n      error\n    } = await supabase.auth.getSession();\n    return !error;\n  } catch (error) {\n    console.error('Supabase connection error:', error);\n    return false;\n  }\n};","map":{"version":3,"names":["supabase","handleError","error","console","Error","message","fetchAvailableSeats","date","lab","dayOrder","data","from","select","eq","bookedSlots","map","booking","time_slot","allTimeSlots","regularClassSlots","availableSlots","slot","available","includes","bookSlot","bookingData","timeSlot","timeSlots","length","bookingPromises","insert","email","name","faculty_id","facultyId","department","day_order","status","results","Promise","all","success","bookings","fetchBookedSlots","waiting","filter","confirmed","rejected","counts","forEach","Date","formatted_date","toLocaleDateString","weekday","year","month","day","deleteBookedSlot","slotId","delete","fetchPendingBookings","adminEmail","order","ascending","handleBookingAction","bookingId","action","newStatus","update","fetchDayOrder","setDayOrderReference","referenceDate","upsert","getDayOrderReferences","checkApiHealth","limit","e","log","auth","getSession"],"sources":["C:/Users/91989/Downloads/Slot-Booking/frontend-supabase/src/services/api.js"],"sourcesContent":["import { supabase } from '../supabaseClient';\r\n\r\n// No longer need API_BASE_URL as we're using Supabase directly\r\n\r\n/**\r\n * Helper function to handle errors\r\n * @param {Error} error - The error object\r\n * @returns {Error} - Formatted error\r\n */\r\nconst handleError = (error) => {\r\n  console.error('API error:', error);\r\n  return new Error(error.message || 'An error occurred with the Supabase request');\r\n};\r\n\r\n/**\r\n * Fetch available seats for a given date and lab\r\n * @param {string} date - The date to fetch available seats for\r\n * @param {string} lab - The lab to fetch available seats for\r\n * @param {string} dayOrder - The manually selected day order\r\n * @returns {Promise<Object>} - Available seats data\r\n */\r\nexport const fetchAvailableSeats = async (date, lab, dayOrder) => {\r\n  try {\r\n    // Query available_seats view or function in Supabase\r\n    const { data, error } = await supabase\r\n      .from('lab_bookings')\r\n      .select('*')\r\n      .eq('date', date)\r\n      .eq('lab', lab)\r\n      .eq('status', 'confirmed');\r\n    \r\n    if (error) throw error;\r\n    \r\n    // Transform data to match the expected format\r\n    const bookedSlots = data.map(booking => booking.time_slot);\r\n    \r\n    // Get all time slots\r\n    const allTimeSlots = [\r\n      \"08:00-08:50\", \"08:50-09:40\", \"09:45-10:35\", \r\n      \"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\", \r\n      \"01:25-02:15\", \"02:20-03:10\", \"03:10-04:00\", \r\n      \"04:00-04:50\"\r\n    ];\r\n\r\n    // Define regular class slots for each lab and day order combination\r\n    const regularClassSlots = {\r\n      'Lab A': {\r\n        '1': [\"08:00-08:50\", \"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\"],\r\n        '2': [\"09:45-10:35\", \"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\"],\r\n        '3': [\"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\", \"02:20-03:10\"],\r\n        '4': [\"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\", \"11:35-12:25\"],\r\n        '5': [\"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\"]\r\n      },\r\n      'Lab B': {\r\n        '1': [\"09:45-10:35\", \"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\"],\r\n        '2': [\"08:00-08:50\", \"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\"],\r\n        '3': [\"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\"],\r\n        '4': [\"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\", \"02:20-03:10\"],\r\n        '5': [\"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\", \"11:35-12:25\"]\r\n      },\r\n      'Lab C': {\r\n        '1': [\"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\", \"02:20-03:10\"],\r\n        '2': [\"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\"],\r\n        '3': [\"08:00-08:50\", \"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\"],\r\n        '4': [\"09:45-10:35\", \"10:40-11:30\", \"11:35-12:25\", \"12:30-01:20\"],\r\n        '5': [\"11:35-12:25\", \"12:30-01:20\", \"01:25-02:15\", \"02:20-03:10\"]\r\n      },\r\n      'Lab D': {\r\n        '1': [\"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"],  // 2:10 PM to 4:30 PM\r\n        '2': [\"01:25-02:15\", \"02:20-03:10\", \"03:10-04:00\", \"04:00-04:50\"],  // 1:25 PM to 4:55 PM\r\n        '3': [\"09:45-10:35\", \"10:40-11:30\"],  // 9:45 AM to 11:30 AM\r\n        '4': [],  // NIL - no slots to freeze\r\n        '5': [\"08:00-08:50\", \"08:50-09:40\", \"09:45-10:35\", \"10:40-11:30\"]  // 8:00 AM to 11:30 AM\r\n      }\r\n    };\r\n    \r\n    // Calculate available slots\r\n    const availableSlots = allTimeSlots.map(slot => ({\r\n      time_slot: slot,\r\n      available: !bookedSlots.includes(slot) && \r\n                (!regularClassSlots[lab] || !regularClassSlots[lab][dayOrder] || !regularClassSlots[lab][dayOrder].includes(slot))\r\n    }));\r\n    \r\n    return { \r\n      availableSlots,\r\n      dayOrder\r\n    };\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Book a lab slot\r\n * @param {Object} bookingData - The booking data\r\n * @returns {Promise<Object>} - Booking confirmation\r\n */\r\nexport const bookSlot = async (bookingData) => {\r\n  try {\r\n    // Ensure timeSlots is an array\r\n    if (bookingData.timeSlot) {\r\n      bookingData.timeSlots = [bookingData.timeSlot];\r\n      delete bookingData.timeSlot;\r\n    } else if (!bookingData.timeSlots) {\r\n      bookingData.timeSlots = [];\r\n    }\r\n\r\n    // Validate required fields\r\n    if (!bookingData.date || !bookingData.lab || !bookingData.timeSlots || bookingData.timeSlots.length === 0) {\r\n      throw new Error('Missing required fields: date, lab, and at least one time slot are required.');\r\n    }\r\n\r\n    // Create a booking for each time slot\r\n    const bookingPromises = bookingData.timeSlots.map(async (timeSlot) => {\r\n      const { data, error } = await supabase\r\n        .from('lab_bookings')\r\n        .insert([\r\n          { \r\n            date: bookingData.date,\r\n            lab: bookingData.lab,\r\n            time_slot: timeSlot,\r\n            email: bookingData.email,\r\n            name: bookingData.name,\r\n            faculty_id: bookingData.facultyId,\r\n            department: bookingData.department,\r\n            day_order: bookingData.dayOrder,\r\n            status: 'waiting' // Initial status is waiting for admin approval\r\n          }\r\n        ])\r\n        .select();\r\n\r\n      if (error) throw error;\r\n      return data[0];\r\n    });\r\n\r\n    const results = await Promise.all(bookingPromises);\r\n    \r\n    return { \r\n      success: true, \r\n      message: 'Booking requests submitted successfully', \r\n      bookings: results \r\n    };\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Fetch booked slots for a user\r\n * @param {string} email - The user's email\r\n * @returns {Promise<Array>} - Array of booked slots with counts\r\n */\r\nexport const fetchBookedSlots = async (email) => {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('lab_bookings')\r\n      .select('*')\r\n      .eq('email', email);\r\n    \r\n    if (error) throw error;\r\n    \r\n    // Calculate counts for each status\r\n    const waiting = data.filter(booking => booking.status === 'waiting').length;\r\n    const confirmed = data.filter(booking => booking.status === 'confirmed').length;\r\n    const rejected = data.filter(booking => booking.status === 'rejected').length;\r\n    \r\n    // Add counts to the response\r\n    data.counts = { waiting, confirmed, rejected };\r\n    \r\n    // Format dates for display\r\n    data.forEach(booking => {\r\n      if (booking.date) {\r\n        const date = new Date(booking.date);\r\n        booking.formatted_date = date.toLocaleDateString('en-US', {\r\n          weekday: 'long',\r\n          year: 'numeric',\r\n          month: 'long',\r\n          day: 'numeric'\r\n        });\r\n      }\r\n    });\r\n    \r\n    return data;\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Delete a booked slot\r\n * @param {number} slotId - The slot ID to delete\r\n * @returns {Promise<Object>} - Deletion confirmation\r\n */\r\nexport const deleteBookedSlot = async (slotId) => {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('lab_bookings')\r\n      .delete()\r\n      .eq('id', slotId)\r\n      .select();\r\n    \r\n    if (error) throw error;\r\n    \r\n    return { success: true, message: 'Booking deleted successfully' };\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Fetch all bookings (admin only)\r\n * @param {string} adminEmail - The admin's email\r\n * @returns {Promise<Array>} - Array of all bookings\r\n */\r\nexport const fetchPendingBookings = async (adminEmail) => {\r\n  try {\r\n    // For now, we'll bypass the admin check to make the function work\r\n    // We'll assume the frontend UI will only show this option to admin users\r\n    \r\n    // Fetch all bookings\r\n    const { data, error } = await supabase\r\n      .from('lab_bookings')\r\n      .select('*')\r\n      .order('date', { ascending: false });\r\n    \r\n    if (error) throw error;\r\n    \r\n    // Format dates for display\r\n    data.forEach(booking => {\r\n      if (booking.date) {\r\n        const date = new Date(booking.date);\r\n        booking.formatted_date = date.toLocaleDateString('en-US', {\r\n          weekday: 'long',\r\n          year: 'numeric',\r\n          month: 'long',\r\n          day: 'numeric'\r\n        });\r\n      }\r\n    });\r\n    \r\n    return data;\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Handle booking action (confirm/reject)\r\n * @param {number} bookingId - The booking ID to update\r\n * @param {string} action - The action to perform ('confirm' or 'reject')\r\n * @param {string} adminEmail - The admin's email\r\n * @returns {Promise<Object>} - Action confirmation\r\n */\r\nexport const handleBookingAction = async (bookingId, action, adminEmail) => {\r\n  try {\r\n    // For now, we'll bypass the admin check to make the function work\r\n    // We'll assume the frontend UI will only show this option to admin users\r\n    \r\n    // Update the booking status\r\n    const newStatus = action === 'confirm' ? 'confirmed' : 'rejected';\r\n    \r\n    const { data, error } = await supabase\r\n      .from('lab_bookings')\r\n      .update({ status: newStatus })\r\n      .eq('id', bookingId)\r\n      .select();\r\n    \r\n    if (error) throw error;\r\n    \r\n    return { \r\n      success: true, \r\n      message: `Booking ${newStatus} successfully`, \r\n      booking: data[0] \r\n    };\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Fetch day order for a date\r\n * @param {string} date - The date to fetch day order for\r\n * @returns {Promise<Object>} - Day order data\r\n */\r\nexport const fetchDayOrder = async (date) => {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('day_orders')\r\n      .select('*')\r\n      .eq('date', date);\r\n    \r\n    if (error) throw error;\r\n    \r\n    return data.length > 0 ? data[0] : { date, day_order: null };\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Set day order reference (admin only)\r\n * @param {string} adminEmail - The admin's email\r\n * @param {string} referenceDate - The reference date\r\n * @param {string} dayOrder - The day order\r\n * @returns {Promise<Object>} - Confirmation\r\n */\r\nexport const setDayOrderReference = async (adminEmail, referenceDate, dayOrder) => {\r\n  try {\r\n    // For now, we'll bypass the admin check to make the function work\r\n    // We'll assume the frontend UI will only show this option to admin users\r\n    \r\n    // Upsert the day order\r\n    const { data, error } = await supabase\r\n      .from('day_orders')\r\n      .upsert([\r\n        { date: referenceDate, day_order: dayOrder }\r\n      ])\r\n      .select();\r\n    \r\n    if (error) throw error;\r\n    \r\n    return { \r\n      success: true, \r\n      message: 'Day order set successfully', \r\n      day_order: data[0] \r\n    };\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n/**\r\n * Get day order references (admin only)\r\n * @param {string} adminEmail - The admin's email\r\n * @returns {Promise<Array>} - Array of day order references\r\n */\r\nexport const getDayOrderReferences = async (adminEmail) => {\r\n  try {\r\n    // For now, we'll bypass the admin check to make the function work\r\n    // We'll assume the frontend UI will only show this option to admin users\r\n    \r\n    // Fetch all day orders\r\n    const { data, error } = await supabase\r\n      .from('day_orders')\r\n      .select('*')\r\n      .order('date', { ascending: false });\r\n    \r\n    if (error) throw error;\r\n    \r\n    return data;\r\n  } catch (error) {\r\n    throw handleError(error);\r\n  }\r\n};\r\n\r\n// Health check function checks if we can connect to Supabase\r\nexport const checkApiHealth = async () => {\r\n  try {\r\n    // First try to fetch a public table that should exist\r\n    try {\r\n      const { error } = await supabase.from('health_check').select('count').limit(1);\r\n      if (!error) return true;\r\n    } catch (e) {\r\n      console.log('Health check table not found, trying alternate method');\r\n    }\r\n    \r\n    // If that fails, try a simple auth ping which should always work\r\n    const { error } = await supabase.auth.getSession();\r\n    return !error;\r\n  } catch (error) {\r\n    console.error('Supabase connection error:', error);\r\n    return false;\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}